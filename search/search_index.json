{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Flask-Mailman","text":"<p>The core part of this extension's source code comes directly from Django's mail module, but with a few interface differences.</p> <p>And following documentation also draws heavily from Django's.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with <code>pip</code>: <pre><code>pip install Flask-Mailman\n</code></pre></p>"},{"location":"#configuration","title":"Configuration","text":"<p>Flask-Mailman is configured through the standard Flask config API. A list of configuration keys currently understood by the extension:</p> <ul> <li> <p>MAIL_SERVER: The host to use for sending email.</p> <p>default \u2018localhost\u2019.</p> </li> <li> <p>MAIL_PORT: Port to use for the SMTP server.</p> <p>default 25.</p> </li> <li> <p>MAIL_USERNAME: Username to use for the SMTP server. If empty, Flask-Mailman won\u2019t attempt authentication.</p> <p>default None.</p> </li> <li> <p>MAIL_PASSWORD: Password to use for the SMTP server defined in MAIL_HOST. This setting is used in conjunction with MAIL_USERNAME when authenticating to the SMTP server. If either of these configs is empty, Flask-Mailman won\u2019t attempt authentication.</p> <p>default None.</p> </li> <li> <p>MAIL_USE_TLS: Whether to use a TLS (secure) connection when talking to the SMTP server. This is used for explicit TLS connections, generally on port 587.</p> <p>default False.</p> </li> <li> <p>MAIL_USE_SSL: Whether to use an implicit TLS (secure) connection when talking to the SMTP server. In most email documentation this type of TLS connection is referred to as SSL. It is generally used on port 465.</p> <p>default False</p> </li> <li> <p>MAIL_TIMEOUT: Specifies a timeout in seconds for blocking operations like the connection attempt.</p> <p>default None.</p> </li> <li> <p>MAIL_SSL_KEYFILE: If MAIL_USE_SSL or MAIL_USE_TLS is True, you can optionally specify the path to a PEM-formatted certificate chain file to use for the SSL connection.</p> <p>default None.</p> </li> <li> <p>MAIL_SSL_CERTFILE: If MAIL_USE_SSL or MAIL_USE_TLS is True, you can optionally specify the path to a PEM-formatted private key file to use for the SSL connection.</p> <p>Note that setting MAIL_SSL_CERTFILE and MAIL_SSL_KEYFILE doesn\u2019t result in any certificate checking. They\u2019re passed to the underlying SSL connection. Please refer to the documentation of Python\u2019s <code>ssl.wrap_socket()</code> function for details on how the certificate chain file and private key file are handled.</p> <p>default None.</p> </li> <li> <p>MAIL_DEFAULT_SENDER: Default email address to use for various automated correspondence from the site manager(s).</p> <p>default None.</p> </li> <li> <p>MAIL_BACKEND: The backend to use for sending emails.</p> <p>Default: 'smtp'. In addition the standard Flask TESTING configuration option is used for testing. When <code>TESTING=True</code> and <code>MAIL_BACKEND</code> is not provided, default will be set to 'locmem'.</p> </li> <li> <p>MAIL_FILE_PATH: The directory used by the file email backend to store output files.</p> <p>Default: Not defined.</p> </li> <li> <p>MAIL_USE_LOCALTIME: Whether to send the SMTP Date header of email messages in the local time zone (True) or in UTC (False).</p> <p>Default: False.</p> </li> <li> <p>MAIL_SEND_OPTIONS: <code>mail_options</code> for <code>smtplib.SMTP.sendmail</code>. If <code>SMTPUTF8</code> is included in <code>MAIL_SEND_OPTIONS</code>, and the server supports it, <code>from_mail</code> and <code>to</code> may contain non-ASCII characters.</p> <p>Default: <code>[]</code></p> </li> </ul> <p>Emails are managed through a Mail instance: <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\napp = Flask(__name__)\nmail = Mail(app)\n</code></pre> In this case all emails are sent using the configuration values of the application that was passed to the Mail class constructor.</p> <p>Alternatively you can set up your Mail instance later at configuration time, using the <code>init_app</code> method: <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\nmail = Mail()\n\napp = Flask(__name__)\nmail.init_app(app)\n</code></pre> In this case emails will be sent using the configuration values from Flask\u2019s <code>current_app</code> context global. This is useful if you have multiple applications running in the same process but with different configuration options.</p>"},{"location":"#sending-messages","title":"Sending messages","text":"<p>To send a message first create a <code>EmailMessage</code> instance: <pre><code>from flask_mailman import EmailMessage\n\nmsg = EmailMessage(\n'Hello',\n'Body goes here',\n'from@example.com',\n['to1@example.com', 'to2@example.com'],\n['bcc@example.com'],\nreply_to=['another@example.com'],\nheaders={'Message-ID': 'foo'},\n)\nmsg.send()\n</code></pre> Then send the message using <code>send()</code> method: <pre><code>from flask_mailman import EmailMessage\n\nmsg = EmailMessage(\n    'Hello',\n    'Body goes here',\n    'from@example.com',\n    ['to1@example.com', 'to2@example.com'],\n    ['bcc@example.com'],\n    reply_to=['another@example.com'],\n    headers={'Message-ID': 'foo'},\n)\nmsg.send()\n</code></pre></p> <p>The <code>EmailMessage</code> class is initialized with the following parameters (in the given order, if positional arguments are used). All parameters are optional and can be set at any time prior to calling the <code>send()</code> method.</p> <ul> <li>subject: The subject line of the email.</li> <li>body: The body text. This should be a plain text message.</li> <li>from_email: The sender\u2019s address. Both <code>fred@example.com</code> or <code>\"Fred\" &lt;fred@example.com&gt;</code> forms are legal. If omitted, the MAIL_DEFAULT_SENDER config is used.</li> <li>to: A list or tuple of recipient addresses.</li> <li>bcc: A list or tuple of addresses used in the \u201cBcc\u201d header when sending the email.</li> <li>connection: An email backend instance. Use this parameter if you want to use the same connection for multiple messages. If omitted, a new connection is created when <code>send()</code> is called.</li> <li>attachments: A list of attachments to put on the message. These can be either MIMEBase instances, or (filename, content, mimetype) triples.</li> <li>headers: A dictionary of extra headers to put on the message. The keys are the header name, values are the header values. It\u2019s up to the caller to ensure header names and values are in the correct format for an email message. The corresponding attribute is <code>extra_headers</code>.</li> <li>cc: A list or tuple of recipient addresses used in the \u201cCc\u201d header when sending the email.</li> <li>reply_to: A list or tuple of recipient addresses used in the \u201cReply-To\u201d header when sending the email.</li> </ul> <p><code>EmailMessage.send(fail_silently=False)</code> sends the message.</p> <p>If a connection was specified when the email was constructed, that connection will be used. Otherwise, an instance of the default backend will be instantiated and used.</p> <p>If the keyword argument <code>fail_silently</code> is True, exceptions raised while sending the message will be quashed. An empty list of recipients will not raise an exception.</p>"},{"location":"#sending-html-content","title":"Sending html content","text":"<p>By default, the MIME type of the body parameter in an <code>EmailMessage</code> is \"text/plain\". It is good practice to leave this alone, because it guarantees that any recipient will be able to read the email, regardless of their mail client. However, if you are confident that your recipients can handle an alternative content type, you can use the <code>content_subtype</code> attribute on the <code>EmailMessage</code> class to change the main content type. The major type will always be \"text\", but you can change the subtype. For example:</p> <pre><code>from flask_mailman import EmailMessage\n\nsubject, from_email, to = 'hello', 'from@example.com', 'to@example.com'\nhtml_content = '&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;'\n\nmsg = EmailMessage(subject, html_content, from_email, [to])\nmsg.content_subtype = \"html\"  # Main content is now text/html\nmsg.send()\n</code></pre>"},{"location":"#sending-multiple-emails","title":"Sending multiple emails","text":"<p>Establishing and closing an SMTP connection (or any other network connection, for that matter) is an expensive process. If you have a lot of emails to send, it makes sense to reuse an SMTP connection, rather than creating and destroying a connection every time you want to send an email.</p> <p>There are two ways you tell an email backend to reuse a connection.</p> <p>Firstly, you can use the <code>send_messages()</code> method. <code>send_messages()</code> takes a list of <code>EmailMessage</code> instances (or subclasses), and sends them all using a single connection.</p> <p>For example, if you have a function called <code>get_notification_email()</code> that returns a list of <code>EmailMessage</code> objects representing some periodic email you wish to send out, you could send these emails using a single call to <code>send_messages</code>:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\napp = Flask(__name__)\nmail = Mail(app)\n\nconnection = mail.get_connection()   # Use default email connection\nmessages = get_notification_email()\nconnection.send_messages(messages)\n</code></pre> <p>In this example, the call to <code>send_messages()</code> opens a connection on the backend, sends the list of messages, and then closes the connection again.</p> <p>The second approach is to use the <code>open()</code> and <code>close()</code> methods on the email backend to manually control the connection. <code>send_messages()</code> will not manually open or close the connection if it is already open, so if you manually open the connection, you can control when it is closed. For example:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail, EmailMessage\n\napp = Flask(__name__)\nmail = Mail(app)\n\nconnection = mail.get_connection()\n\n# Manually open the connection\nconnection.open()\n\n# Construct an email message that uses the connection\nemail1 = EmailMessage(\n    'Hello',\n    'Body goes here',\n    'from@example.com',\n    ['to1@example.com'],\n    connection=connection,\n)\nemail1.send() # Send the email\n\n# Construct two more messages\nemail2 = EmailMessage(\n    'Hello',\n    'Body goes here',\n    'from@example.com',\n    ['to2@example.com'],\n)\nemail3 = EmailMessage(\n    'Hello',\n    'Body goes here',\n    'from@example.com',\n    ['to3@example.com'],\n)\n\n# Send the two emails in a single call -\nconnection.send_messages([email2, email3])\n# The connection was already open so send_messages() doesn't close it.\n# We need to manually close the connection.\nconnection.close()\n</code></pre> <p>Of course there is always a short writing using <code>with</code>:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail, EmailMessage\n\napp = Flask(__name__)\nmail = Mail(app)\n\nwith mail.get_connection() as conn:\n    email1 = EmailMessage(\n    'Hello',\n    'Body goes here',\n    'from@example.com',\n    ['to1@example.com'],\n    connection=conn,\n    )\n    email1.send()\n\n    email2 = EmailMessage(\n        'Hello',\n        'Body goes here',\n        'from@example.com',\n        ['to2@example.com'],\n    )\n    email3 = EmailMessage(\n        'Hello',\n        'Body goes here',\n        'from@example.com',\n        ['to3@example.com'],\n    )\n    conn.send_messages([email2, email3])\n</code></pre>"},{"location":"#attachments","title":"Attachments","text":"<p>You can use the following two methods to adding attachments:</p> <ul> <li> <p><code>EmailMessage.attach()</code> creates a new file attachment and adds it to the message. There are two ways to call <code>attach()</code>:</p> <ul> <li> <p>You can pass it a single argument that is a MIMEBase instance. This will be inserted directly into the resulting message.</p> </li> <li> <p>Alternatively, you can pass <code>attach()</code> three arguments: filename, content and mimetype. filename is the name of the file attachment as it will appear in the email, content is the data that will be contained inside the attachment and mimetype is the optional MIME type for the attachment. If you omit mimetype, the MIME content type will be guessed from the filename of the attachment.</p> <p>For example:</p> <pre><code>message.attach('design.png', img_data, 'image/png')\n</code></pre> <p>If you specify a mimetype of message/rfc822, it will also accept <code>flask_mailman.EmailMessage</code> and <code>email.message.Message</code>.</p> <p>For a mimetype starting with text/, content is expected to be a string. Binary data will be decoded using UTF-8, and if that fails, the MIME type will be changed to application/octet-stream and the data will be attached unchanged.</p> <p>In addition, message/rfc822 attachments will no longer be base64-encoded in violation of RFC 2046#section-5.2.1, which can cause issues with displaying the attachments in Evolution and Thunderbird.</p> </li> </ul> </li> <li> <p><code>EmailMessage.attach_file()</code> creates a new attachment using a file from your filesystem. Call it with the path of the file to attach and, optionally, the MIME type to use for the attachment. If the MIME type is omitted, it will be guessed from the filename. You can use it like this:</p> <pre><code>message.attach_file('/images/weather_map.png')\n</code></pre> <p>For MIME types starting with text/, binary data is handled as in <code>attach()</code>.</p> </li> </ul>"},{"location":"#preventing-header-injection","title":"Preventing header injection","text":"<p>Header injection is a security exploit in which an attacker inserts extra email headers to control the \u201cTo:\u201d and \u201cFrom:\u201d in email messages that your scripts generate.</p> <p>The Flask-Mailman email methods outlined above all protect against header injection by forbidding newlines in header values. If any <code>subject</code>, <code>from_email</code> or <code>recipient_list</code> contains a newline (in either Unix, Windows or Mac style), the email method (e.g. <code>send_mail()</code>) will raise <code>flask_mailman.BadHeaderError</code> (a subclass of <code>ValueError</code>) and, hence, will not send the email. It\u2019s your responsibility to validate all data before passing it to the email functions.</p> <p>If a message contains headers at the start of the string, the headers will be printed as the first bit of the email message.</p>"},{"location":"#sending-alternative-content-types","title":"Sending alternative content types","text":"<p>It can be useful to include multiple versions of the content in an email; the classic example is to send both text and HTML versions of a message. With this library, you can do this using the <code>EmailMultiAlternatives</code> class. This subclass of <code>EmailMessage</code> has an <code>attach_alternative()</code> method for including extra versions of the message body in the email. All the other methods (including the class initialization) are inherited directly from <code>EmailMessage</code>.</p> <p>To send a text and HTML combination, you could write:</p> <pre><code>from flask_mailman import EmailMultiAlternatives\n\nsubject, from_email, to = 'hello', 'from@example.com', 'to@example.com'\ntext_content = 'This is an important message.'\nhtml_content = '&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;'\nmsg = EmailMultiAlternatives(subject, text_content, from_email, [to])\nmsg.attach_alternative(html_content, \"text/html\")\nmsg.send()\n</code></pre>"},{"location":"#email-backends","title":"Email backends","text":"<p>The actual sending of an email is handled by the email backend.</p> <p>The email backend class has the following methods:</p> <ul> <li><code>open()</code> instantiates a long-lived email-sending connection.</li> <li><code>close()</code> closes the current email-sending connection.</li> </ul> <p><code>send_messages(email_messages)</code> sends a list of <code>EmailMessage</code> objects. If the connection is not open, this call will implicitly open the connection, and close the connection afterwards. If the connection is already open, it will be left open after mail has been sent. It can also be used as a context manager, which will automatically call <code>open()</code> and <code>close()</code> as needed:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\napp = Flask(__name__)\nmail = Mail(app)\n\nwith mail.get_connection() as connection:\n    mail.EmailMessage(\n        subject1, body1, from1, [to1],\n        connection=connection,\n    ).send()\n    mail.EmailMessage(\n        subject2, body2, from2, [to2],\n        connection=connection,\n    ).send()\n</code></pre>"},{"location":"#obtaining-an-instance-of-an-email-backend","title":"Obtaining an instance of an email backend","text":"<p>The <code>get_connection()</code> method of Mail instance returns an instance of the email backend that you can use.</p> <p><pre><code>Mail.get_connection(backend=None, fail_silently=False, *args, **kwargs)\n</code></pre> By default, a call to <code>get_connection()</code> will return an instance of the email backend specified in MAIL_BACKEND configuration. If you specify the backend argument, an instance of that backend will be instantiated.</p> <p>The <code>fail_silently</code> argument controls how the backend should handle errors. If <code>fail_silently</code> is True, exceptions during the email sending process will be silently ignored.</p> <p>All other arguments are passed directly to the constructor of the email backend.</p> <p>Flask-Mailman ships with several email sending backends. With the exception of the SMTP backend (which is the default), these backends are only useful during testing and development. If you have special email sending requirements, you can write your own email backend.</p>"},{"location":"#smtp-backend","title":"SMTP backend","text":"<p><pre><code>class backends.smtp.EmailBackend(\n    host=None,\n    port=None,\n    username=None,\n    password=None,\n    use_tls=None,\n    fail_silently=False,\n    use_ssl=None,\n    timeout=None,\n    ssl_keyfile=None,\n    ssl_certfile=None,\n    **kwargs\n)\n</code></pre> This is the default backend. Email will be sent through a SMTP server.</p> <p>The value for each argument is retrieved from the matching configuration if the argument is None:</p> <ul> <li>host: MAIL_HOST</li> <li>port: MAIL_PORT</li> <li>username: MAIL_USERNAME</li> <li>password: MAIL_PASSWORD</li> <li>use_tls: MAIL_USE_TLS</li> <li>use_ssl: MAIL_USE_SSL</li> <li>timeout: MAIL_TIMEOUT</li> <li>ssl_keyfile: MAIL_SSL_KEYFILE</li> <li>ssl_certfile: MAIL_SSL_CERTFILE</li> </ul> <p>The SMTP backend is the default configuration inherited by Flask-Mailman. If you want to specify it explicitly, put the following in your configurations:</p> <p><pre><code>MAIL_BACKEND = 'smtp'\n</code></pre> If unspecified, the default timeout will be the one provided by <code>socket.getdefaulttimeout()</code>, which defaults to None (no timeout).</p>"},{"location":"#console-backend","title":"Console backend","text":"<p>Instead of sending out real emails the console backend just writes the emails that would be sent to the standard output. By default, the console backend writes to stdout. You can use a different stream-like object by providing the stream keyword argument when constructing the connection.</p> <p>To specify this backend, put the following in your settings:</p> <p><pre><code>MAIL_BACKEND = 'console'\n</code></pre> This backend is not intended for use in production \u2013 it is provided as a convenience that can be used during development.</p>"},{"location":"#file-backend","title":"File backend","text":"<p>The file backend writes emails to a file. A new file is created for each new session that is opened on this backend. The directory to which the files are written is either taken from the MAIL_FILE_PATH configuration or from the <code>file_path</code> keyword when creating a connection with <code>Mail.get_connection()</code>.</p> <p>To specify this backend, put the following in your configurations:</p> <p><pre><code>MAIL_BACKEND = 'file'\nMAIL_FILE_PATH = '/tmp/app-messages' # change this to a proper location\n</code></pre> This backend is not intended for use in production \u2013 it is provided as a convenience that can be used during development.</p> <p>Support for <code>pathlib.Path</code> was added.</p>"},{"location":"#in-memory-backend","title":"In-memory backend","text":"<p>The 'locmem' backend stores messages in a special attribute of the Mail instance. The <code>outbox</code> attribute is created when the backend is first created (e.g. by sending a message or calling <code>.get_connection()</code>). It\u2019s a list with an <code>EmailMessage</code> instance for each message that would be sent.</p> <p>To specify this backend, put the following in your configurations:</p> <pre><code>MAIL_BACKEND = 'locmem'\n</code></pre> <p>This backend is not intended for use in production \u2013 it is provided as a convenience that can be used during development and testing.</p> <p>When <code>TESTING=True</code> and <code>MAIL_BACKEND</code> is not provided, this backend will be used for testing.</p>"},{"location":"#dummy-backend","title":"Dummy backend","text":"<p>As the name suggests the dummy backend does nothing with your messages. To specify this backend, put the following in your configurations:</p> <pre><code>MAIL_BACKEND = 'dummy'\n</code></pre> <p>This backend is not intended for use in production \u2013 it is provided as a convenience that can be used during development.</p>"},{"location":"#defining-a-custom-email-backend","title":"Defining a custom email backend","text":"<p>If you need to change how emails are sent you can write your own email backend. The <code>MAIL_BACKEND</code> configuration in your settings file is then the Python import path for your backend class. for example:</p> <pre><code>MAIL_BACKEND = 'flask_mailman.backens.custom'\n</code></pre> <p>A more direct way is to import your custom backend class, and pass it to <code>flask_mailman.get_connection</code> function:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\nfrom your_custom_backend import CustomBackend\n\napp = Flask(__name__)\nmail = Mail(app)\n\nconnection = mail.get_connection(backend=CustomBackend)\nconnection.send_messages(messages)\n</code></pre> <p>Custom email backends should subclass <code>BaseEmailBackend</code> that is located in the <code>flask_mailman.backends.base</code> module. A custom email backend must implement the <code>send_messages(email_messages)</code> method. This method receives a list of <code>EmailMessage</code> instances and returns the number of successfully delivered messages. If your backend has any concept of a persistent session or connection, you should also implement the <code>open()</code> and <code>close()</code> methods.</p> <p>Refer to <code>flask_mailman.backends.smtp.EmailBackend</code> for a reference implementation.</p>"},{"location":"#convenient-functions","title":"Convenient functions","text":""},{"location":"#send_mail","title":"send_mail()","text":"<p>send_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None, html_message=None)</p> <p>In most cases, you can send email using <code>Mail.send_mail()</code>.</p> <p>The subject, message, from_email and recipient_list parameters are required.</p> <ul> <li>subject: A string.</li> <li>message: A string.</li> <li>from_email: A string. If None, Flask-Mailman will use the value of the MAIL_DEFAULT_SENDER configuration.</li> <li>recipient_list: A list of strings, each an email address. Each member of <code>recipient_list</code> will see the other recipients in the \u201cTo:\u201d field of the email message.</li> <li>fail_silently: A boolean. When it\u2019s False, <code>send_mail()</code> will raise an <code>smtplib.SMTPException</code> if an error occurs. See the smtplib docs for a list of possible exceptions, all of which are subclasses of <code>SMTPException</code>.</li> <li>auth_user: The optional username to use to authenticate to the SMTP server. If this isn\u2019t provided, Flask-Mailman will use the value of the MAIL_USERNAME configuration.</li> <li>auth_password: The optional password to use to authenticate to the SMTP server. If this isn\u2019t provided, Flask-Mailman will use the value of the MAIL_PASSWORD configuration.</li> <li>connection: The optional email backend to use to send the mail. If unspecified, an instance of the default backend will be used. See the documentation on Email backends for more details.</li> <li>html_message: If <code>html_message</code> is provided, the resulting email will be a multipart/alternative email with message as the text/plain content type and html_message as the text/html content type.</li> </ul> <p>The return value will be the number of successfully delivered messages (which can be 0 or 1 since it can only send one message).</p>"},{"location":"#send_mass_mail","title":"send_mass_mail()","text":"<p>send_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None)</p> <p><code>Mail.send_mass_mail()</code> is intended to handle mass emailing.</p> <p>datatuple is a tuple in which each element is in this format:</p> <p><pre><code>(subject, message, from_email, recipient_list)\n</code></pre> <code>fail_silently</code>, <code>auth_user</code> and <code>auth_password</code> have the same functions as in <code>send_mail()</code>.</p> <p>Each separate element of datatuple results in a separate email message. As in <code>send_mail()</code>, recipients in the same <code>recipient_list</code> will all see the other addresses in the email messages\u2019 \u201cTo:\u201d field.</p> <p>For example, the following code would send two different messages to two different sets of recipients; however, only one connection to the mail server would be opened:</p> <pre><code>from flask import Flask\nfrom flask_mailman import Mail\n\napp = Flask(__name__)\nmail = Mail(app)\n\nmessage1 = ('Subject here', 'Here is the message', 'from@example.com', ['first@example.com', 'other@example.com'])\nmessage2 = ('Another Subject', 'Here is another message', 'from@example.com', ['second@test.com'])\nmail.send_mass_mail((message1, message2), fail_silently=False)\n# The return value will be the number of successfully delivered messages.\n</code></pre>"},{"location":"#send_mass_mail-vs-send_mail","title":"send_mass_mail() vs. send_mail()","text":"<p>The main difference between <code>send_mass_mail()</code> and <code>send_mail()</code> is that <code>send_mail()</code> opens a connection to the mail server each time it\u2019s executed, while <code>send_mass_mail()</code> uses a single connection for all of its messages. This makes <code>send_mass_mail()</code> slightly more efficient.</p>"},{"location":"#differences-with-django","title":"Differences with Django","text":"<p>The name of configuration keys is different here, but you can easily resolve it.</p> <p><code>mail_admins()</code> and <code>mail_managers()</code> methods were removed, you can write an alternative one in a minute if you need.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#111-2024-07-06","title":"[1.1.1] - 2024-07-06","text":"<ul> <li>Fix SafeMIMEText.set_payload() crash on Python 3.13 (#80).</li> </ul>"},{"location":"changelog/#110-2024-4-22","title":"[1.1.0] - 2024-4-22","text":"<ul> <li>Add configuration key <code>MAIL_SEND_OPTIONS</code> to support setting <code>mail_options</code> for <code>smtplib.SMTP.send_mail</code>   (e.g. <code>SMTPUTF8</code>) (#61).</li> <li>Pre-encodes FQDN str with punycode to improve compatibility (#66).</li> <li>Migrates as many as possible test cases from Django mail module (#64).</li> <li>Improve way of populating smtp key/cert to avoid TypeError in py&gt;=12 (#68).</li> </ul>"},{"location":"changelog/#100-2023-11-04","title":"[1.0.0] - 2023-11-04","text":"<ul> <li>Drop Python 3.6 support.</li> <li>Fix compatibility issue with Python 3.10   (#31).</li> <li>Fix the log file generation issue to ensure that the log filename is random   (#30).</li> <li>Fix compatibility issue with Python 3.12   (#56).</li> <li>Support passing <code>from_email</code> in tuple format to <code>send_mail()</code> function   (#35).</li> </ul>"},{"location":"changelog/#030-2021-08-08","title":"[0.3.0] - 2021-08-08","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add support for custom email backend.</li> </ul>"},{"location":"changelog/#024-2021-06-15","title":"[0.2.4] - 2021-06-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Tox and GitHub workflows to run test, staging and release automatically.</li> </ul>"},{"location":"changelog/#023","title":"[0.2.3]","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Add support for Flask 2.0</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Drop support for Python 3.5(due to flask upgrade).</li> </ul>"},{"location":"changelog/#022","title":"[0.2.2]","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Set <code>None</code> as the default value for the <code>from_email</code> and <code>recipient_list</code> of <code>send_mail()</code> function.</li> </ul>"},{"location":"changelog/#020","title":"[0.2.0]","text":"<p>A few breaking changes have been made in this version to ensure that API of this extension is basically the same as Django. Users migrating from Flask-Mail should upgrade with caution.</p>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Add documentation site hosted in GitHub Pages.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Set configuration value of in-memory backend to 'locmem'.</li> <li>Set MAIL_SERVER default value to 'locaohost'.</li> <li>Set MAIL_USE_LOCALTIME default value to False.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Remove <code>Mail.send()</code> method and <code>Message()</code> class which borrowing from Flask-Mail.</li> <li>Remove <code>mail_admins()</code> and <code>mail_managers()</code> method that come from Django.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/waynerv/flask-mailman/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Flask-Mailman could always use more documentation, whether as part of the official Flask-Mailman docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/waynerv/flask-mailman/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>flask-mailman</code> for local development.</p> <ol> <li>Fork the <code>flask-mailman</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/flask-mailman.git\n</code></pre> </li> <li> <p>Ensure poetry is installed.</p> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ poetry run tox\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9. Check    https://github.com/waynerv/flask-mailman/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ poetry run pytest tests/test_flask_mailman.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>$ poetry run bump2version patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"}]}